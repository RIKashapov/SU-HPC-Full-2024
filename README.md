## Сравнение производительности перемножения матриц на CPU и GPU

## Введение
Этот проект сравнивает производительность перемножения матриц на CPU и GPU с использованием библиотек Python: NumPy и CuPy. Основная цель - измерить ускорение, достигнутое благодаря использованию GPU.

## Реализация
### Реализация на CPU
Реализация на CPU использует функцию dot из библиотеки NumPy для перемножения матриц.

### Реализация на GPU
Реализация на GPU использует функцию dot из библиотеки CuPy, которая предназначена для выполнения матричных операций с ускорением на GPU.

## Эксперименты
Были проведены эксперименты с квадратными матрицами размером от 100x100 до 2000x2000. Измерялась и сравнивалась производительность обеих реализаций.

## Результаты
|Размер матрицы|	Время на CPU (с)	|   Время на GPU (с)   |	    Ускорение       |
|--------------|--------------------|----------------------|-----------------------|
|100x100       |0.0                 |0.0013456344604492188 |0.0                    |
|500x500       |0.002047300338745117|0.029321908950805664  |0.06982152294995325    |
|1000x1000     |0.011034965515136719|0.18382668495178223   |0.06002918193314095    |
|1500x1500     |0.027208566665649414|0.10141682624816895   |0.2682845408617848     |
|2000x2000     |0.06555914878845215 |0.18271517753601074   |0.35880516152267267    |

## Вывод
Результаты показывают значительное ускорение при использовании GPU для перемножения матриц, особенно для больших размеров матриц. Это обусловлено возможностями параллельной обработки на GPU, которые хорошо подходят для матричных операций.

## Сравнение производительности суммы элементов вектора на CPU и GPU

## Описание
В данной лабораторной работе реализованы две функции для суммирования элементов вектора: одна на CPU и другая на GPU с использованием CUDA.

## Реализация
### CPU
Для суммирования элементов вектора на CPU используется библиотека `NumPy`, которая предоставляет оптимизированные функции для работы с массивами.

### GPU
Для суммирования элементов вектора на GPU используется библиотека `cuPy`, которая позволяет легко переносить данные на GPU и выполнять вычисления параллельно с использованием CUDA.

## Параллелизация на GPU
Параллелизация на GPU осуществляется за счет использования большого количества потоков, которые одновременно обрабатывают элементы вектора. Это позволяет значительно ускорить вычисления по сравнению с последовательной обработкой на CPU.

## Эксперименты
Были проведены эксперименты для векторов разных размеров. Результаты показаны в таблице ниже:

| Размер вектора | Время на CPU (с) | Время на GPU (с) |
|----------------|------------------|------------------|
| 1000           | 0.0000           | 0.0720           |
| 10000          | 0.0000           | 0.0001           |
| 100000         | 0.0004           | 0.0007           |
| 1000000        | 0.0066           | 0.0067           |
| 10000000       | 0.0657           | 0.0677           |

В связи с получением странных результатов повторил код в colab. Результаты также сохранены в файле `results1.csv`.

## Выводы
Результаты экспериментов показывают, что использование GPU для суммирования элементов вектора становится значительно более эффективным при увеличении размера вектора. Для малых векторов время на GPU может быть больше из-за дополнительных затрат на передачу данных.

#№ Median Filter with PyCUDA

Этот проект реализует медианный фильтр с использованием CUDA для обработки изображений. Он использует PyCUDA для компиляции и запуска CUDA-ядра, а также применяет медианный фильтр для улучшения качества изображений.

## Описание

1. **Медианный фильтр** - это нелинейный фильтр, используемый для устранения шума на изображениях. Он заменяет каждый пиксель на медиану в окне вокруг него.
   
2. **PyCUDA** - библиотека для взаимодействия с CUDA через Python. В данном проекте используется для работы с GPU для ускоренной обработки изображений.

3. **Используемые технологии**:
   - Python 3
   - PyCUDA для работы с GPU
   - CUDA для реализации медианного фильтра

## Основная часть скрипта выполняет следующие шаги:

1. Загружает изображение с помощью функции load_image.
2. Создает CUDA массив для хранения данных изображения на GPU.
3. Настраивает параметры копирования данных для передачи изображения на GPU.
4. Определяет и компилирует CUDA ядро для медианного фильтра.
5. Выполняет медианный фильтр на GPU.
6. Копирует результат обратно на CPU и сохраняет его в файл с помощью функции save_image.

## Генерация Спектрограммы и Сравнение Производительности FFTW и CUFFT

## Описание

Этот проект реализует создание спектрограммы аудиофайла в формате WAV с использованием библиотек FFTW (для CPU) и CUFFT (для GPU). Также производится сравнение производительности двух библиотек.

## Требования

Для выполнения данного проекта необходимы следующие библиотеки:
- Python 3.6 или выше
- numpy
- scipy
- matplotlib
- pycuda
- cupy

## Основная часть скрипта выполняет следующие шаги:
1. Чтение WAV файла
2. Вычисление спектограммы с использованием FFTW (для CPU)
3. Вычисление спектрограммы с использованием CUFFT (для GPU):
4. Сохранение спектрограммы в файл:

## Результаты

1. Время вычисления спектрограммы с использованием FFTW (CPU) и CUFFT (GPU) было измерено и выведено на экран.
2. Спектрограммы были сохранены в файлы spectrogram_cpu.png и spectrogram_gpu.png.